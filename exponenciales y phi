rm(list = ls())
library(spatstat)
library(cubature)
#simulacion LGCP
N=500
sig=1
W=square(1) ### 1.- Considerar el tama単o de la ventana en las integrales
Warea=spatstat.geom::area(W)
mu0=log(N/Warea)-sig/2
phi=0.15
X <- rLGCP(model="exp", mu=mu0, var=sig, scale=phi, win = W) ### (*).- Crear mi propio simulador de LGCP
Z<-attr(X,"Lambda")
plot(Z)
points(X,pch=16)

rmax <- 0.2 ### 2.- A単adirlo como parte de las funciones que necesiten closepairs y crosspairs
P<-closepairs(X,rmax,twice = TRUE) 
#Supuestos:
#Homogeneidad
#Estacioneriedad
#las funcion jac pide el proceso puntual (para calcular la sumatoria) y un conjunto de puntos (para calcular la integral por el metodo montecarlo)
#la funcion jac devuelve una matriz 
#la funciones pcf, y est devuelven un vector
#la funcion est pide la cordenada que se desea calcular
#Mejora entregar dos listas de parametros uno que sean lineales y otros no lineales

#Considerar diferentes w_{ij}
lavn<- function(X,g,est,jac,inipar,tol,kmax,mc=1000, trace = TRUE){
  W=X$w ### 1.- Considerar el tama単o de la ventana en las integrales
  Warea=spatstat.geom::area(W)
  x0<-runifpoint(mc,win=W)
  y0<-runifpoint(mc,win=W)
  dU<-crosspairs(x0,y0,rmax,what="ijd")
  P<-closepairs(X,rmax,twice = TRUE)
  par=inipar
  for(i in 1:kmax){
    r=c()
    for (j in 1:length(par)) {
      s=sum(est(P$d,par,j))
      int=(Warea)^2*1/mc*1/mc*sum(g(dU$d,par)*est(dU$d,par,j))*(intensity(X))^2
      e=s-int
      r=c(r,e)
    }
    gra=r
    jacob=jac(X,P$d,dU$d,par,mc,g)
    jacob=solve(jacob)
    para=par
    step=jacob%*%gra
    print(jacob)
    print(gra)
    par=par-(step)[,1]
    e=sqrt(sum((para-par)*(para-par)))/sqrt(sum(para*para))
    if(e<tol){
      return(par)}
    if(trace) cat(par^2, i, "\n")
  }
  return(par)
}



gexp <- function(x,par){
  n=length(par)/2
  a=0
  for (i in 1:n){
    a=a+par[i]^2*exp(-x/exp(par[i+n]))
  }
  a=exp(a)
  return(a)
}

dexp<-function(d,par1,j){
  a=0
  n=length(par1)/2
  if(j<=n){
    a=2*par1[j]*exp(-d/exp(par1[j+n]))
  }
  else{
    a=par1[j-n]^2*exp(-d/exp(par1[j]))*exp(-par1[j])*d
  }
  return(a)
}


dexpm<-function(X,dp,du,par1,mc,gexp){
  ja=c()
  W=X$w ### 1.- Considerar el tama単o de la ventana en las integrales
  Warea=spatstat.geom::area(W)
  rho=(intensity(X))^2
  n=length(par1)/2
  jac=matrix(,nrow=2*n,ncol=2*n)
  f1<- function(d,i){
    if(i<=n){
    e=exp(-d/par1[i+n])}
    else {
      e=exp(-d/par1[i])
    }
  }
  sumf<-function (d,i,j){
    a=0
    if (i==j){
      a=sum(f1(d,i))*2
    }
    return(a)
  }
  intf<-function(d,i,j){
    a=0
    if (i==j){
      a=2*gexp(d,par1)*f1(d,i)+4*(par1[i])^2*gexp(du,par1)
    }
    else {
      a=4*par1[i]*par1[j]*f1(d,i)*f1(d,j)*gexp(du,par1)
    }
    a=sum(a)*(1/mc)*(1/mc)*(Warea)^2*rho
    return(a)
  }
  for (i in 1:n){
    for (j in i:n){
      su=sumf(dp,i,j)
      int=intf(du,i,j)
      ij=su-int
      jac[i,j]=ij
      jac[j,i]=ij
    }
    
  }
  sumf2<-function (d,i,j){
    a=0
    if (i==j){
      a=par1[i-n]^2*f1(d,i)*exp(-par1[i])*d*(exp(-par1[i])*d-1)
      a=sum(a)
    }
    return(a)
  }
  intf2<-function(d,i,j){
    a=0
    if (i==j){
      a=gexp(d,par1)*f1(d,i)*par1[i-n]^2 *exp(-par1[i])*d*(f1(d,i)*exp(-par1[i])*d*par1[i-n]^2+exp(-par1[i])*d-1)
    }
    else {
      a=par1[i-n]^2*par1[j-n]^2*f1(d,i)*f1(d,j)*gexp(du,par1)*exp(-par1[i])*exp(-par1[j])*d^2
    }
    a=sum(a)*(1/mc)*(1/mc)*(Warea)^2*rho
    return(a)
  }
  for (i in (n+1):(2*n)){
    for (j in (n+1):(2*n)){
      su=sumf2(dp,i,j)
      int=intf2(du,i,j)
      ij=su-int
      jac[i,j]=ij
      jac[j,i]=ij
    }
    
  }
  sumf3<-function (d,i,j){
    a=0
    if (i==(j-n)){
      a=2*par1[i]*f1(d,i)*exp(-par1[i])*d
      a=sum(a)
    }
    return(a)
  }
  intf3<-function(d,i,j){
    a=0
    if (i==(j-n)){
      a=gexp(d,par1)*2*par1[i]*f1(d,i)*exp(-par1[j])*d*(1+par1[i]^2*f1(d,i))
    }
    else {
      a=gexp(du,par1)*2*par1[i]*f1(d,i)*2*par1[j-n]*f1(d,j)*exp(-par1[j])*d
    }
    a=sum(a)*(1/mc)*(1/mc)*(Warea)^2*rho
    return(a)
  }
  for (i in 1:n){
    for (j in (n+1):(2*n)){
      su=sumf3(dp,i,j)
      int=intf3(du,i,j)
      ij=su-int
      jac[i,j]=ij
      jac[j,i]=ij
    }
    
  }
  
  return(jac)
}


#no me funciona  min.cv <- mincontrast(observed = pcf(X), gexp(x,par), startpar = c(sqrt(0.5),sqrt(0.5),sqrt(0.5),sqrt(0.5),sqrt(0.5)))
# idem anterior min.cv <- mincontrast(observed = pcf(X), theoretical = function(x,par){ exp((par[1]^2)*exp(-x/0.15)+(par[2]^2)*exp(-x/0.25)+(par[3]^2)*exp(-x/0.35)+(par[4]^2)*exp(-x/0.45)+(par[5]^2)*exp(-x/0.55))}, startpar = c(sqrt(0.5),sqrt(0.5),sqrt(0.5),sqrt(0.5),sqrt(0.5)))
# min.cv
#pcf(X)

dexp(c(0,0.2),par,2)
par
par=c(0.7,5,log(0.15),log(3))
n=length(par)
par[n-1]
par^2 
exp(par)

re<-lavn(X,gexp,dexp,dexpm,inipar=par,tol= 1e-15,kmax=1000,mc=1000, trace = TRUE)
